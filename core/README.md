# Core
This [program](print_flag) was about to print the flag when it died. Maybe the flag is still in this [core](core) file that it dumped? Also available at /problems/core_2_6f573d741fe8c5c6518e4a29f04a1e19 on the shell server.


## Solution
This problem took me some time to figure out. With the given files I knew we were dealing with a [Core Dump](https://en.wikipedia.org/wiki/Core_dump), however I did not know how to debug it. Eventually I found this helpful [StacksOverflow post](https://stackoverflow.com/questions/8305866/how-do-i-analyze-a-programs-core-dump-file-with-gdb-when-it-has-command-line-pa). This problem was a great opportunity for me to learn more about [gdb](https://en.wikipedia.org/wiki/GNU_Debugger).


Just by starting gdb we get a very big hint:

```
$ gdb print_flag --core core
Core was generated by `/opt/hacksports/staging/core_2_2663584505521277/problem_files/print_flag'.
Program terminated with signal SIGTRAP, Trace/breakpoint trap.
#0  print_flag () at ./print_flag.c:90
90      ./print_flag.c: No such file or directory.
(gdb) 
```

The program was terminated by a breakpoint at *line 90* in `print_flag.c`. We could use the `info line` command to find where *line 90* starts and ends.

```
(gdb) info line 90
Line 90 of "./print_flag.c" starts at address 0x80487c1 <print_flag> and ends at 0x80487c7 <print_flag+6>.
```

When we disassemble the code at address `0x80487c1` we see:

```
(gdb) disassemble 0x80487c1
Dump of assembler code for function print_flag:
=> 0x080487c1 <+0>:     push   ebp
   0x080487c2 <+1>:     mov    ebp,esp
   0x080487c4 <+3>:     sub    esp,0x18
   0x080487c7 <+6>:     mov    DWORD PTR [ebp-0xc],0x539
   0x080487ce <+13>:    mov    eax,DWORD PTR [ebp-0xc]
   0x080487d1 <+16>:    mov    eax,DWORD PTR [eax*4+0x804a080]
   0x080487d8 <+23>:    sub    esp,0x8
   0x080487db <+26>:    push   eax
   0x080487dc <+27>:    push   0x804894c
   0x080487e1 <+32>:    call   0x8048410 <printf@plt>
   0x080487e6 <+37>:    add    esp,0x10
   0x080487e9 <+40>:    nop
   0x080487ea <+41>:    leave  
   0x080487eb <+42>:    ret    
End of assembler dump.
```

It took me some time to figure out what was happening here but I eventually figured it out. This `print_flag()` function is [printing a formatted string](https://www.cplusplus.com/reference/cstdio/printf/). The `format` is at address `0x804894c`. We could use the `x/s` command to print the format string:

```
(gdb) x/s 0x804894c
0x804894c:      "your flag is: picoCTF{%s}\n"
```

Thus the flag is whatever string that is being pointed at by the pointer in register `eax`. Reading the logic of this function we see that the pointer in `eax` is whatever value that is in `0x539*4 + 0x804a080`. Using the `x` command we could get this value:

```
(gdb) x 0x539*4 + 0x804a080
0x804b564 <strs+5348>:  0x080610f0
```

Thus, the flag is located at address `0x080610f0`, so we print that address using `x/s`.

```
(gdb) x/s 0x080610f0
0x80610f0:      "31b1f6d7550619d1f774bef9c4c0e2e8"
(gdb)
```

### Flag
Putting everything together we get the flag `picoCTF{31b1f6d7550619d1f774bef9c4c0e2e8}`.


## Hints
- What is a core file?
- You may find this [reference](https://darkdust.net/files/GDB%20Cheat%20Sheet.pdf) helpful.
- Try to figure out where the flag was read into memory using the disassembly and [strace](https://linux.die.net/man/1/strace).
- You should study the format options on the cheat sheet and use the examine (x) or print (p) commands. disas may also be useful.
